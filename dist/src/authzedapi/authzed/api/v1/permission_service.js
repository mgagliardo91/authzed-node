"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionsService = exports.LookupSubjectsResponse = exports.LookupSubjectsRequest = exports.LookupResourcesResponse = exports.LookupResourcesRequest = exports.ExpandPermissionTreeResponse = exports.ExpandPermissionTreeRequest = exports.CheckPermissionResponse = exports.CheckPermissionRequest = exports.DeleteRelationshipsResponse = exports.DeleteRelationshipsRequest = exports.WriteRelationshipsResponse = exports.WriteRelationshipsRequest = exports.Precondition = exports.ReadRelationshipsResponse = exports.ReadRelationshipsRequest = exports.SubjectFilter_RelationFilter = exports.SubjectFilter = exports.RelationshipFilter = exports.Consistency = exports.CheckPermissionResponse_Permissionship = exports.Precondition_Operation = void 0;
// @generated by protobuf-ts 2.0.7 with parameter generate_dependencies,long_type_string,client_grpc1
// @generated from protobuf file "authzed/api/v1/permission_service.proto" (package "authzed.api.v1", syntax proto3)
// tslint:disable
const runtime_rpc_1 = require("@protobuf-ts/runtime-rpc");
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const core_1 = require("./core");
const core_2 = require("./core");
const core_3 = require("./core");
const core_4 = require("./core");
const core_5 = require("./core");
const core_6 = require("./core");
/**
 * @generated from protobuf enum authzed.api.v1.Precondition.Operation
 */
var Precondition_Operation;
(function (Precondition_Operation) {
    /**
     * @generated from protobuf enum value: OPERATION_UNSPECIFIED = 0;
     */
    Precondition_Operation[Precondition_Operation["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: OPERATION_MUST_NOT_MATCH = 1;
     */
    Precondition_Operation[Precondition_Operation["MUST_NOT_MATCH"] = 1] = "MUST_NOT_MATCH";
    /**
     * @generated from protobuf enum value: OPERATION_MUST_MATCH = 2;
     */
    Precondition_Operation[Precondition_Operation["MUST_MATCH"] = 2] = "MUST_MATCH";
})(Precondition_Operation = exports.Precondition_Operation || (exports.Precondition_Operation = {}));
/**
 * @generated from protobuf enum authzed.api.v1.CheckPermissionResponse.Permissionship
 */
var CheckPermissionResponse_Permissionship;
(function (CheckPermissionResponse_Permissionship) {
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_UNSPECIFIED = 0;
     */
    CheckPermissionResponse_Permissionship[CheckPermissionResponse_Permissionship["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_NO_PERMISSION = 1;
     */
    CheckPermissionResponse_Permissionship[CheckPermissionResponse_Permissionship["NO_PERMISSION"] = 1] = "NO_PERMISSION";
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_HAS_PERMISSION = 2;
     */
    CheckPermissionResponse_Permissionship[CheckPermissionResponse_Permissionship["HAS_PERMISSION"] = 2] = "HAS_PERMISSION";
})(CheckPermissionResponse_Permissionship = exports.CheckPermissionResponse_Permissionship || (exports.CheckPermissionResponse_Permissionship = {}));
// @generated message type with reflection information, may provide speed optimized methods
class Consistency$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.Consistency", [
            { no: 1, name: "minimize_latency", kind: "scalar", oneof: "requirement", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 2, name: "at_least_as_fresh", kind: "message", oneof: "requirement", T: () => core_6.ZedToken },
            { no: 3, name: "at_exact_snapshot", kind: "message", oneof: "requirement", T: () => core_6.ZedToken },
            { no: 4, name: "fully_consistent", kind: "scalar", oneof: "requirement", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } }
        ]);
    }
    create(value) {
        const message = { requirement: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool minimize_latency */ 1:
                    message.requirement = {
                        oneofKind: "minimizeLatency",
                        minimizeLatency: reader.bool()
                    };
                    break;
                case /* authzed.api.v1.ZedToken at_least_as_fresh */ 2:
                    message.requirement = {
                        oneofKind: "atLeastAsFresh",
                        atLeastAsFresh: core_6.ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.requirement.atLeastAsFresh)
                    };
                    break;
                case /* authzed.api.v1.ZedToken at_exact_snapshot */ 3:
                    message.requirement = {
                        oneofKind: "atExactSnapshot",
                        atExactSnapshot: core_6.ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.requirement.atExactSnapshot)
                    };
                    break;
                case /* bool fully_consistent */ 4:
                    message.requirement = {
                        oneofKind: "fullyConsistent",
                        fullyConsistent: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool minimize_latency = 1; */
        if (message.requirement.oneofKind === "minimizeLatency")
            writer.tag(1, runtime_1.WireType.Varint).bool(message.requirement.minimizeLatency);
        /* authzed.api.v1.ZedToken at_least_as_fresh = 2; */
        if (message.requirement.oneofKind === "atLeastAsFresh")
            core_6.ZedToken.internalBinaryWrite(message.requirement.atLeastAsFresh, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ZedToken at_exact_snapshot = 3; */
        if (message.requirement.oneofKind === "atExactSnapshot")
            core_6.ZedToken.internalBinaryWrite(message.requirement.atExactSnapshot, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool fully_consistent = 4; */
        if (message.requirement.oneofKind === "fullyConsistent")
            writer.tag(4, runtime_1.WireType.Varint).bool(message.requirement.fullyConsistent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.Consistency
 */
exports.Consistency = new Consistency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationshipFilter$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.RelationshipFilter", [
            { no: 1, name: "resource_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 2, name: "optional_resource_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_][a-zA-Z0-9/_|-]{0,127})?$" } } } },
            { no: 3, name: "optional_relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 4, name: "optional_subject_filter", kind: "message", T: () => exports.SubjectFilter }
        ]);
    }
    create(value) {
        const message = { resourceType: "", optionalResourceId: "", optionalRelation: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string resource_type */ 1:
                    message.resourceType = reader.string();
                    break;
                case /* string optional_resource_id */ 2:
                    message.optionalResourceId = reader.string();
                    break;
                case /* string optional_relation */ 3:
                    message.optionalRelation = reader.string();
                    break;
                case /* authzed.api.v1.SubjectFilter optional_subject_filter */ 4:
                    message.optionalSubjectFilter = exports.SubjectFilter.internalBinaryRead(reader, reader.uint32(), options, message.optionalSubjectFilter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string resource_type = 1; */
        if (message.resourceType !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.resourceType);
        /* string optional_resource_id = 2; */
        if (message.optionalResourceId !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.optionalResourceId);
        /* string optional_relation = 3; */
        if (message.optionalRelation !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.optionalRelation);
        /* authzed.api.v1.SubjectFilter optional_subject_filter = 4; */
        if (message.optionalSubjectFilter)
            exports.SubjectFilter.internalBinaryWrite(message.optionalSubjectFilter, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.RelationshipFilter
 */
exports.RelationshipFilter = new RelationshipFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubjectFilter$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.SubjectFilter", [
            { no: 1, name: "subject_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 2, name: "optional_subject_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^(([a-zA-Z0-9_][a-zA-Z0-9/_|-]{0,127})|\\*)?$" } } } },
            { no: 3, name: "optional_relation", kind: "message", T: () => exports.SubjectFilter_RelationFilter }
        ]);
    }
    create(value) {
        const message = { subjectType: "", optionalSubjectId: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subject_type */ 1:
                    message.subjectType = reader.string();
                    break;
                case /* string optional_subject_id */ 2:
                    message.optionalSubjectId = reader.string();
                    break;
                case /* authzed.api.v1.SubjectFilter.RelationFilter optional_relation */ 3:
                    message.optionalRelation = exports.SubjectFilter_RelationFilter.internalBinaryRead(reader, reader.uint32(), options, message.optionalRelation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string subject_type = 1; */
        if (message.subjectType !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.subjectType);
        /* string optional_subject_id = 2; */
        if (message.optionalSubjectId !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.optionalSubjectId);
        /* authzed.api.v1.SubjectFilter.RelationFilter optional_relation = 3; */
        if (message.optionalRelation)
            exports.SubjectFilter_RelationFilter.internalBinaryWrite(message.optionalRelation, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.SubjectFilter
 */
exports.SubjectFilter = new SubjectFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubjectFilter_RelationFilter$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.SubjectFilter.RelationFilter", [
            { no: 1, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } }
        ]);
    }
    create(value) {
        const message = { relation: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string relation */ 1:
                    message.relation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string relation = 1; */
        if (message.relation !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.relation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.SubjectFilter.RelationFilter
 */
exports.SubjectFilter_RelationFilter = new SubjectFilter_RelationFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRelationshipsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.ReadRelationshipsRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => exports.Consistency },
            { no: 2, name: "relationship_filter", kind: "message", T: () => exports.RelationshipFilter, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = exports.Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* authzed.api.v1.RelationshipFilter relationship_filter */ 2:
                    message.relationshipFilter = exports.RelationshipFilter.internalBinaryRead(reader, reader.uint32(), options, message.relationshipFilter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            exports.Consistency.internalBinaryWrite(message.consistency, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.RelationshipFilter relationship_filter = 2; */
        if (message.relationshipFilter)
            exports.RelationshipFilter.internalBinaryWrite(message.relationshipFilter, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ReadRelationshipsRequest
 */
exports.ReadRelationshipsRequest = new ReadRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRelationshipsResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.ReadRelationshipsResponse", [
            { no: 1, name: "read_at", kind: "message", T: () => core_6.ZedToken },
            { no: 2, name: "relationship", kind: "message", T: () => core_5.Relationship }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken read_at */ 1:
                    message.readAt = core_6.ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.readAt);
                    break;
                case /* authzed.api.v1.Relationship relationship */ 2:
                    message.relationship = core_5.Relationship.internalBinaryRead(reader, reader.uint32(), options, message.relationship);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.ZedToken read_at = 1; */
        if (message.readAt)
            core_6.ZedToken.internalBinaryWrite(message.readAt, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.Relationship relationship = 2; */
        if (message.relationship)
            core_5.Relationship.internalBinaryWrite(message.relationship, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ReadRelationshipsResponse
 */
exports.ReadRelationshipsResponse = new ReadRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Precondition$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.Precondition", [
            { no: 1, name: "operation", kind: "enum", T: () => ["authzed.api.v1.Precondition.Operation", Precondition_Operation, "OPERATION_"], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "filter", kind: "message", T: () => exports.RelationshipFilter, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value) {
        const message = { operation: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Precondition.Operation operation */ 1:
                    message.operation = reader.int32();
                    break;
                case /* authzed.api.v1.RelationshipFilter filter */ 2:
                    message.filter = exports.RelationshipFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.Precondition.Operation operation = 1; */
        if (message.operation !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.operation);
        /* authzed.api.v1.RelationshipFilter filter = 2; */
        if (message.filter)
            exports.RelationshipFilter.internalBinaryWrite(message.filter, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.Precondition
 */
exports.Precondition = new Precondition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteRelationshipsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.WriteRelationshipsRequest", [
            { no: 1, name: "updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => core_4.RelationshipUpdate, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } },
            { no: 2, name: "optional_preconditions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.Precondition, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } }
        ]);
    }
    create(value) {
        const message = { updates: [], optionalPreconditions: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v1.RelationshipUpdate updates */ 1:
                    message.updates.push(core_4.RelationshipUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated authzed.api.v1.Precondition optional_preconditions */ 2:
                    message.optionalPreconditions.push(exports.Precondition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated authzed.api.v1.RelationshipUpdate updates = 1; */
        for (let i = 0; i < message.updates.length; i++)
            core_4.RelationshipUpdate.internalBinaryWrite(message.updates[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.Precondition optional_preconditions = 2; */
        for (let i = 0; i < message.optionalPreconditions.length; i++)
            exports.Precondition.internalBinaryWrite(message.optionalPreconditions[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.WriteRelationshipsRequest
 */
exports.WriteRelationshipsRequest = new WriteRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteRelationshipsResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.WriteRelationshipsResponse", [
            { no: 1, name: "written_at", kind: "message", T: () => core_6.ZedToken }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken written_at */ 1:
                    message.writtenAt = core_6.ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.writtenAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.ZedToken written_at = 1; */
        if (message.writtenAt)
            core_6.ZedToken.internalBinaryWrite(message.writtenAt, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.WriteRelationshipsResponse
 */
exports.WriteRelationshipsResponse = new WriteRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRelationshipsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.DeleteRelationshipsRequest", [
            { no: 1, name: "relationship_filter", kind: "message", T: () => exports.RelationshipFilter, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "optional_preconditions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.Precondition, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } }
        ]);
    }
    create(value) {
        const message = { optionalPreconditions: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.RelationshipFilter relationship_filter */ 1:
                    message.relationshipFilter = exports.RelationshipFilter.internalBinaryRead(reader, reader.uint32(), options, message.relationshipFilter);
                    break;
                case /* repeated authzed.api.v1.Precondition optional_preconditions */ 2:
                    message.optionalPreconditions.push(exports.Precondition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.RelationshipFilter relationship_filter = 1; */
        if (message.relationshipFilter)
            exports.RelationshipFilter.internalBinaryWrite(message.relationshipFilter, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.Precondition optional_preconditions = 2; */
        for (let i = 0; i < message.optionalPreconditions.length; i++)
            exports.Precondition.internalBinaryWrite(message.optionalPreconditions[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.DeleteRelationshipsRequest
 */
exports.DeleteRelationshipsRequest = new DeleteRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRelationshipsResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.DeleteRelationshipsResponse", [
            { no: 1, name: "deleted_at", kind: "message", T: () => core_6.ZedToken }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken deleted_at */ 1:
                    message.deletedAt = core_6.ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.deletedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.ZedToken deleted_at = 1; */
        if (message.deletedAt)
            core_6.ZedToken.internalBinaryWrite(message.deletedAt, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.DeleteRelationshipsResponse
 */
exports.DeleteRelationshipsResponse = new DeleteRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPermissionRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.CheckPermissionRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => exports.Consistency },
            { no: 2, name: "resource", kind: "message", T: () => core_3.ObjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 4, name: "subject", kind: "message", T: () => core_2.SubjectReference, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value) {
        const message = { permission: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = exports.Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* authzed.api.v1.ObjectReference resource */ 2:
                    message.resource = core_3.ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string permission */ 3:
                    message.permission = reader.string();
                    break;
                case /* authzed.api.v1.SubjectReference subject */ 4:
                    message.subject = core_2.SubjectReference.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            exports.Consistency.internalBinaryWrite(message.consistency, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ObjectReference resource = 2; */
        if (message.resource)
            core_3.ObjectReference.internalBinaryWrite(message.resource, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string permission = 3; */
        if (message.permission !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.permission);
        /* authzed.api.v1.SubjectReference subject = 4; */
        if (message.subject)
            core_2.SubjectReference.internalBinaryWrite(message.subject, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.CheckPermissionRequest
 */
exports.CheckPermissionRequest = new CheckPermissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPermissionResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.CheckPermissionResponse", [
            { no: 1, name: "checked_at", kind: "message", T: () => core_6.ZedToken },
            { no: 2, name: "permissionship", kind: "enum", T: () => ["authzed.api.v1.CheckPermissionResponse.Permissionship", CheckPermissionResponse_Permissionship, "PERMISSIONSHIP_"] }
        ]);
    }
    create(value) {
        const message = { permissionship: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken checked_at */ 1:
                    message.checkedAt = core_6.ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.checkedAt);
                    break;
                case /* authzed.api.v1.CheckPermissionResponse.Permissionship permissionship */ 2:
                    message.permissionship = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.ZedToken checked_at = 1; */
        if (message.checkedAt)
            core_6.ZedToken.internalBinaryWrite(message.checkedAt, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 2; */
        if (message.permissionship !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.permissionship);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.CheckPermissionResponse
 */
exports.CheckPermissionResponse = new CheckPermissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandPermissionTreeRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.ExpandPermissionTreeRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => exports.Consistency },
            { no: 2, name: "resource", kind: "message", T: () => core_3.ObjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } }
        ]);
    }
    create(value) {
        const message = { permission: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = exports.Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* authzed.api.v1.ObjectReference resource */ 2:
                    message.resource = core_3.ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string permission */ 3:
                    message.permission = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            exports.Consistency.internalBinaryWrite(message.consistency, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ObjectReference resource = 2; */
        if (message.resource)
            core_3.ObjectReference.internalBinaryWrite(message.resource, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string permission = 3; */
        if (message.permission !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.permission);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpandPermissionTreeRequest
 */
exports.ExpandPermissionTreeRequest = new ExpandPermissionTreeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandPermissionTreeResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.ExpandPermissionTreeResponse", [
            { no: 1, name: "expanded_at", kind: "message", T: () => core_6.ZedToken },
            { no: 2, name: "tree_root", kind: "message", T: () => core_1.PermissionRelationshipTree }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken expanded_at */ 1:
                    message.expandedAt = core_6.ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.expandedAt);
                    break;
                case /* authzed.api.v1.PermissionRelationshipTree tree_root */ 2:
                    message.treeRoot = core_1.PermissionRelationshipTree.internalBinaryRead(reader, reader.uint32(), options, message.treeRoot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.ZedToken expanded_at = 1; */
        if (message.expandedAt)
            core_6.ZedToken.internalBinaryWrite(message.expandedAt, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.PermissionRelationshipTree tree_root = 2; */
        if (message.treeRoot)
            core_1.PermissionRelationshipTree.internalBinaryWrite(message.treeRoot, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpandPermissionTreeResponse
 */
exports.ExpandPermissionTreeResponse = new ExpandPermissionTreeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupResourcesRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.LookupResourcesRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => exports.Consistency },
            { no: 2, name: "resource_object_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 3, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 4, name: "subject", kind: "message", T: () => core_2.SubjectReference, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value) {
        const message = { resourceObjectType: "", permission: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = exports.Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* string resource_object_type */ 2:
                    message.resourceObjectType = reader.string();
                    break;
                case /* string permission */ 3:
                    message.permission = reader.string();
                    break;
                case /* authzed.api.v1.SubjectReference subject */ 4:
                    message.subject = core_2.SubjectReference.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            exports.Consistency.internalBinaryWrite(message.consistency, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string resource_object_type = 2; */
        if (message.resourceObjectType !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.resourceObjectType);
        /* string permission = 3; */
        if (message.permission !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.permission);
        /* authzed.api.v1.SubjectReference subject = 4; */
        if (message.subject)
            core_2.SubjectReference.internalBinaryWrite(message.subject, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.LookupResourcesRequest
 */
exports.LookupResourcesRequest = new LookupResourcesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupResourcesResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.LookupResourcesResponse", [
            { no: 1, name: "looked_up_at", kind: "message", T: () => core_6.ZedToken },
            { no: 2, name: "resource_object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { resourceObjectId: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken looked_up_at */ 1:
                    message.lookedUpAt = core_6.ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.lookedUpAt);
                    break;
                case /* string resource_object_id */ 2:
                    message.resourceObjectId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.ZedToken looked_up_at = 1; */
        if (message.lookedUpAt)
            core_6.ZedToken.internalBinaryWrite(message.lookedUpAt, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string resource_object_id = 2; */
        if (message.resourceObjectId !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.resourceObjectId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.LookupResourcesResponse
 */
exports.LookupResourcesResponse = new LookupResourcesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupSubjectsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.LookupSubjectsRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => exports.Consistency },
            { no: 2, name: "resource", kind: "message", T: () => core_3.ObjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 4, name: "subject_object_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 5, name: "optional_subject_relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } }
        ]);
    }
    create(value) {
        const message = { permission: "", subjectObjectType: "", optionalSubjectRelation: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = exports.Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* authzed.api.v1.ObjectReference resource */ 2:
                    message.resource = core_3.ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string permission */ 3:
                    message.permission = reader.string();
                    break;
                case /* string subject_object_type */ 4:
                    message.subjectObjectType = reader.string();
                    break;
                case /* string optional_subject_relation */ 5:
                    message.optionalSubjectRelation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            exports.Consistency.internalBinaryWrite(message.consistency, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ObjectReference resource = 2; */
        if (message.resource)
            core_3.ObjectReference.internalBinaryWrite(message.resource, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string permission = 3; */
        if (message.permission !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.permission);
        /* string subject_object_type = 4; */
        if (message.subjectObjectType !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.subjectObjectType);
        /* string optional_subject_relation = 5; */
        if (message.optionalSubjectRelation !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.optionalSubjectRelation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.LookupSubjectsRequest
 */
exports.LookupSubjectsRequest = new LookupSubjectsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupSubjectsResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("authzed.api.v1.LookupSubjectsResponse", [
            { no: 1, name: "looked_up_at", kind: "message", T: () => core_6.ZedToken },
            { no: 2, name: "subject_object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "excluded_subject_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { subjectObjectId: "", excludedSubjectIds: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            runtime_3.reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken looked_up_at */ 1:
                    message.lookedUpAt = core_6.ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.lookedUpAt);
                    break;
                case /* string subject_object_id */ 2:
                    message.subjectObjectId = reader.string();
                    break;
                case /* repeated string excluded_subject_ids */ 3:
                    message.excludedSubjectIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* authzed.api.v1.ZedToken looked_up_at = 1; */
        if (message.lookedUpAt)
            core_6.ZedToken.internalBinaryWrite(message.lookedUpAt, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string subject_object_id = 2; */
        if (message.subjectObjectId !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.subjectObjectId);
        /* repeated string excluded_subject_ids = 3; */
        for (let i = 0; i < message.excludedSubjectIds.length; i++)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.excludedSubjectIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.LookupSubjectsResponse
 */
exports.LookupSubjectsResponse = new LookupSubjectsResponse$Type();
/**
 * @generated ServiceType for protobuf service authzed.api.v1.PermissionsService
 */
exports.PermissionsService = new runtime_rpc_1.ServiceType("authzed.api.v1.PermissionsService", [
    { name: "ReadRelationships", serverStreaming: true, options: { "google.api.http": { body: "*", post: "/v1/relationships/read" } }, I: exports.ReadRelationshipsRequest, O: exports.ReadRelationshipsResponse },
    { name: "WriteRelationships", options: { "google.api.http": { body: "*", post: "/v1/relationships/write" } }, I: exports.WriteRelationshipsRequest, O: exports.WriteRelationshipsResponse },
    { name: "DeleteRelationships", options: { "google.api.http": { body: "*", post: "/v1/relationships/delete" } }, I: exports.DeleteRelationshipsRequest, O: exports.DeleteRelationshipsResponse },
    { name: "CheckPermission", options: { "google.api.http": { body: "*", post: "/v1/permissions/check" } }, I: exports.CheckPermissionRequest, O: exports.CheckPermissionResponse },
    { name: "ExpandPermissionTree", options: { "google.api.http": { body: "*", post: "/v1/permissions/expand" } }, I: exports.ExpandPermissionTreeRequest, O: exports.ExpandPermissionTreeResponse },
    { name: "LookupResources", serverStreaming: true, options: { "google.api.http": { body: "*", post: "/v1/permissions/resources" } }, I: exports.LookupResourcesRequest, O: exports.LookupResourcesResponse },
    { name: "LookupSubjects", serverStreaming: true, options: { "google.api.http": { body: "*", post: "/v1/permissions/subjects" } }, I: exports.LookupSubjectsRequest, O: exports.LookupSubjectsResponse }
]);
//# sourceMappingURL=permission_service.js.map